#+EXPORT_FILE_NAME: ../../episodes/release_engineering.md
#+OPTIONS: toc:nil author:nil date:nil num:nil title:nil
#+MACRO: mdheader @@markdown:$1@@
#+PROPERTY: header-args:bash :results output :exports both :cache yes :wrap src bash

#+begin_export markdown
---
title: "Release Engineering: Logs and Artifacts"
teaching: 25
exercises: 15
---
#+end_export

#+begin_questions
- How do I manage release notes without merge conflicts?
- How do I publish my package to the world (safely)?
#+end_questions

#+begin_objectives
- Use =towncrier= to manage changelogs using fragments.
- Build package artifacts using =uv build=.
- Publish packages to TestPyPI using =uvx twine=.
#+end_objectives

* The Changelog Problem

Before we publish code, we need to tell our users what changed.
The naive way is to edit a =CHANGELOG.md= file manually.
*The Problem:* If two people define a new feature in a Pull Request, they both edit the top of =CHANGELOG.md=. This causes *Merge Conflicts*.

#+BEGIN_SRC dot :file ../../episodes/fig/towncrier-flow.png :cmdline -Kdot -Tpng -Gdpi=150 :cache yes :exports none
digraph Changelog {
    rankdir=TB;
    node [fontname="Helvetica", style=filled, shape=box];
    edge [fontname="Helvetica", fontsize=10];

    subgraph cluster_manual {
        label="The Manual Way (Conflict!)";
        style=dashed;
        color="#e57373";
        margin=10;

        devA [label="Dev A adds Feature\n(Edits Line 1)", fillcolor="#ffccbc"];
        devB [label="Dev B adds Fix\n(Edits Line 1)", fillcolor="#ffe0b2"];
        conflict [label="MERGE CONFLICT\n(Both edited same line)", shape=octagon, fillcolor="#ff5252", fontcolor="white"];

        devA -> conflict;
        devB -> conflict;
    }

    subgraph cluster_towncrier {
        label="The Towncrier Way (Fragments)";
        style=dashed;
        color="#81c784";
        margin=10;

        fragA [label="news/123.feature", shape=note, fillcolor="#c8e6c9"];
        fragB [label="news/124.bugfix", shape=note, fillcolor="#c8e6c9"];
        
        tc [label="towncrier build", shape=component, fillcolor="#a5d6a7"];
        
        final [label="CHANGELOG.md\n(Generated List)", shape=note, fillcolor="#ffffff"];

        fragA -> tc;
        fragB -> tc;
        tc -> final [label="Compiles & Deletes Fragments"];
    }
}
#+END_SRC

#+RESULTS[6ff334cf65755111435e734967c8cc777ccfe9ee]:

@@markdown:![Comparison diagram showing manual changelog edits causing merge conflicts versus towncrier compiling separate fragment files](fig/towncrier-flow.png)@@

** Solution: Towncrier

*Towncrier* solves this by using "News Fragments". Instead of editing one big file, you create a tiny file for each change.

Let's set it up.

#+begin_src bash
# Add towncrier to our dev tools
uv add --dev towncrier
#+end_src

Add the configuration to =pyproject.toml=:

#+begin_src toml filename="pyproject.toml"
[tool.towncrier]
package = "chemlib"
filename = "CHANGELOG.md"
directory = "news"
#+end_src

Now, create the news directory:
#+begin_src bash
mkdir news
#+end_src

*** Creating a News Fragment

Imagine we just added the =center_of_mass= function. We create a file in =news/=. The name must end with the type of change (=.feature=, =.bugfix=, =.doc=).

#+begin_src bash
echo "Added center_of_mass function to geometry module." > news/1.feature
#+end_src

When we are ready to release, we run:

#+begin_src bash
uv run towncrier build --version 0.1.0
#+end_src

Towncrier will:
1. Collect all files in =news/=.
2. Format them into a bulleted list.
3. Prepend them to =CHANGELOG.md=.
4. Delete the fragment files.

No merge conflicts, ever!

* Building Artifacts

Now that our docs are ready, we need to package our code. Python uses two formats:
1.  *sdist (.tar.gz):* The raw source code.
2.  *Wheel (.whl):* A pre-built, ready-to-install archive.

 #+BEGIN_SRC dot :file ../../episodes/fig/python-artifacts.png :cmdline -Kdot -Tpng -Gdpi=150 :cache yes :exports none
digraph Artifacts {
    rankdir=LR;
    node [fontname="Helvetica", style=filled];
    edge [fontname="Helvetica", fontsize=10];

    src [label="Source Code\n(src/chemlib)", shape=folder, fillcolor="#fff9c4"];
    
    build [label="uv build", shape=component, fillcolor="#29b6f6", fontcolor="white"];

    subgraph cluster_dist {
        label="dist/ folder";
        style=filled;
        fillcolor="#e1f5fe";
        
        sdist [label="sdist (.tar.gz)\nRaw Source", shape=note, fillcolor="#ffffff"];
        whl [label="wheel (.whl)\nPre-built / Ready", shape=note, fillcolor="#b3e5fc"];
    }

    src -> build;
    build -> sdist;
    build -> whl;
}
#+END_SRC

#+RESULTS[ff6cc63b07955e43a56fff3cca469220ced75d78]:

@@markdown:![Flowchart showing source code processed by uv build into sdist tarball and wheel file](fig/python-artifacts.png)@@  

With =uv=, building is trivial:

#+begin_src bash
uv build
#+end_src

#+begin_example
Building source distribution...
Building wheel...
Successfully built dist/chemlib-0.1.0.tar.gz and dist/chemlib-0.1.0-py3-none-any.whl
#+end_example

* Publishing to TestPyPI

We are finally ready to ship.

#+BEGIN_SRC dot :file ../../episodes/fig/publish-workflow.png :cmdline -Kdot -Tpng -Gdpi=150 :cache yes :exports none
digraph Publish {
    rankdir=LR;
    node [fontname="Helvetica", style=filled];
    edge [fontname="Helvetica", fontsize=10];

    // Actors
    dev [label="Developer", shape=ellipse, fillcolor="#e0e0e0"];
    
    // Actions
    uvx [label="uvx twine upload", shape=box, style="rounded,filled", fillcolor="#ab47bc", fontcolor="white"];
    
    // Systems
    pypi [label="TestPyPI\n(Repository)", shape=cylinder, fillcolor="#90caf9"];
    
    // Auth
    token [label="API Token\n(pypi-...)", shape=key, fillcolor="#fff59d"];

    // Flow
    dev -> uvx [label="Executes"];
    token -> uvx [label="Authenticates"];
    uvx -> pypi [label="Uploads dist/*"];
}
#+END_SRC

#+RESULTS[ab7a391f9af12161a48e2f2e034cb705edbe2b21]:
[[file:../../episodes/fig/publish-workflow.png]]

@@markdown:![Sequence showing developer using uvx twine with an API token to upload artifacts to TestPyPI](fig/publish-workflow.png)@@

#+begin_callout
*Warning:* The real PyPI is permanent. For this workshop, we use *TestPyPI* (test.pypi.org), which is a separate repository. By default, PyPI is used for resolution.
#+end_callout

*Step 1: Get a Token*
1.  Go to [[https://test.pypi.org/][TestPyPI]] and create an account.
2.  Go to Settings -> API Tokens -> Create "Entire account" token.
3.  Copy the token (starts with =pypi-=).

*Step 2: Upload using Twine*
We don't need to install =twine= permanently. We can use =uvx= (the tool execution runner) to fetch and run it in one go.

#+begin_src bash
# Replace __token__ with your actual token value
uvx twine upload \
    --repository testpypi \
    --username __token__ \
    --password pypi-AgENdGVzdC5we... \
    dist/*
#+end_src

If successful, you can now see your package on the TestPyPI website, and can be
installed with

#+begin_src bash
uv pip install -i "TEST_PYPI_URL"
#+end_src

#+begin_challenge

{{{mdheader(## Challenge: The Full Cycle)}}}

You have built the artifact. Now prove it works!

Upload your package to TestPyPI using the credentials you generated.

Create a one-line script =check_install.py=: =import chemlib; print(chemlib.file)=.

Use =uv run= to execute this script, but force it to install your package from TestPyPI.

#+begin_hint
TestPyPI is a separate "index" (a library catalog). You will need to tell =uv= where to look using the flag =--extra-index-url https://test.pypi.org/simple/=. We use "extra" so it can still find dependencies like =numpy= on the main PyPI.
#+end_hint

#+begin_solution
1. Upload:

#+begin_src bash
uvx twine upload --repository testpypi dist/*
#+end_src

2. Verify: We use =--with chemlib= to request an ephemeral environment containing our package.

#+begin_src bash
echo "import chemlib; print('Success:', chemlib.file)" > check_install.py
uv run --extra-index-url https://test.pypi.org/simple/ --with chemlib check_install.py
#+end_src

Output:
#+begin_example
Success: .../uv/.../site-packages/chemlib/init.py
#+end_example
#+end_solution
#+end_challenge

* Automating Release (GitHub Actions)

#+begin_caution
*Warning:* This may *not be a good idea*, since PyPI releases cannot be removed. It is better to set this up for TestPyPI and manually use =twine= or =uv= or =pdm publish= and others locally after ensuring everything works.
#+end_caution

We can teach GitHub to do this for us. We use *Trusted Publishing (OIDC)* so we
don't even need to copy-paste passwords.

Add a =release= job to your =.github/workflows/ci.yml=:

#+begin_src yaml
  release:
    needs: check
    if: github.event_name == 'push' && startsWith(github.ref, 'refs/tags/v')
    runs-on: ubuntu-latest
    permissions:
      id-token: write  # Required for OIDC
      contents: read
    
    steps:
      - uses: actions/checkout@v4
      - uses: astral-sh/setup-uv@v5
      
      - name: Build
        run: uv build
      
      - name: Publish to TestPyPI
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          repository-url: https://test.pypi.org/legacy/
          # No password needed if configured in PyPI settings!
#+end_src

Now, whenever you push a tag (e.g., =v0.1.0=), GitHub will build and ship your code automatically.

#+begin_keypoints
- *Towncrier* prevents changelog conflicts by using "News Fragments".
- *uv build* creates standard =sdist= and =wheel= artifacts.
- *uvx twine* allows one-off publishing without polluting your environment.
- *TestPyPI* is the sandbox for practicing release engineering.
#+end_keypoints

# Local Variables:
# eval: (add-hook 'after-save-hook 'export-as-workbench-md nil t)
# End:
